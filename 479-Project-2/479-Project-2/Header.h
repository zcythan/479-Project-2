#pragma once
#include <iostream>
#include <string>
/* Authors: Chance Galvin & John Ferrick
 * Creation Date: 20230325
 * Modification Date: 20230325 @ 3PM by Chance Galvin
 * Grader Notes:
*/

/* Feel free to convert this to a linked list class.
   Being written up as a 2D array for simplicity in calculation of the logic and navigation of the maze.
  Structs are like tables in lua, which is my preferred language, so I like them, but I am not attached */
struct mazeSquare {

	// If class, 
	// mazeSquare->north,->east,etc

	// Neighboring tiles, in order presecribed by instructions
	// To be populated with information 
	std::string
		// Ex: A1 or 1A
		ID = "\0",
		// Ids of neighbor. Ex: ID=1A, m.east = 2A
		// "\0" is can be found by looking for nullptr, which is easier than searching for a '0' in a string
		// nullptr = wall
		// Can be split into two characters - first character = row, second char = col
		west = "\0",
		north = "\0",
		east = "\0",
		south = "\0";
	// Is this space an obstacle? 1 = yes, 0 = no
	bool obstacle = 0;
	// To hold whether or not the neighbors are sensed obstacles/walls or empty 
	// 'c' in "cnorth" simply stands for "clear" because I didn't want to spend too much time thinking
	// on naming conventions. Feel free to rewrite the names. 
	// 0 = Our neighbor is sensed to be empty, 1 = our neighbor is sensed to be obstructed
	bool cwest = 0, cnorth = 0, ceast = 0, csouth = 0;

	// To hold whether or not the neighbors are ACTUALLY obstacles/walls or empty
	// Can be used to fact-check our own logic
	bool awest = 0, anorth = 0, aeast = 0, asouth = 0;

	// Probability of being correct
	// Initially, loop through the maze and run sensedAcc() 
	// Can be called later on in the program if we ever need to fact-check or run updates (like after a move) 
	double pwest = 0, pnorth = 0, peast = 0, psouth = 0;

	// -- Other Decimal Probabilities--
	// Chances that we initially start on this particular square to be outputted to the menu
	// Decided by generateInitLocProb()
	double initStartProbD = 0;
	// Generated by eviCondProb()
	double EviCondD = 0;
	// Prediction 
	double predictD = 0;
	double filteringD = 0;

	// -- Percentage Probabilities--
	// These get outputted to the menus
	double initStartPerc = 0, EvidenceCondPerc = 0;

};

// This is to hold the sequence given us in 
struct action {
	// Action number 
	int ID = 0;
	// 0 = sense, 1 = move
	bool type = 0;
	// Item order: W, N, E, S
	// 0 = open, 1 = blocked
	bool blocked[3];
	// If movement, what direction?
	// 1 = W, 2 = N, 3 = E, 4 = S
	int dir;
};

// -- GLOBALS--
// Putting this in global is bad practice, but figured it might be better to for program accuracy long-run
// Maze is actually 7x6 but we start counting at 0
mazeSquare maze[5][6];
//void generatePrediction(maze m, int dir);
double sensedDirAcc(bool beingChecked);
void generateSequence(action a);
void initializeMazeTest2();



// The below functions are in the header just in case we want to turn them into class methods

// Feel free to turn this into a class method as well if we go that route 
// Actual thinking is being done in sensedDirAcc()
// One function accuracy checks a whole node, the second just a single item in the node
// This is done to save time, space, confusion, and adds versatillity 
void sensedNodeAcc(mazeSquare m) {
	m.pwest = sensedDirAcc(m.cwest);
	m.pnorth = sensedDirAcc(m.cnorth);
	m.peast = sensedDirAcc(m.ceast);
	m.psouth = sensedDirAcc(m.csouth);
}

// Comes up with a probability for our accuracy on our individual directions. 
double sensedDirAcc(bool beingChecked) {
	switch (beingChecked) {
		// Chances that the sensing was correct
	// Made this a variable to stop errors from just returning the value outright 
		double returnable;
	case 0:
		returnable = 0.95;
		return returnable;
		break;
	case 1:
		returnable = 0.9;
		return returnable;
		break;
	}
	return 0;
}

// Call this function after every change of state 
void eviCondProb(mazeSquare m) {
	m.EviCondD = (m.pnorth * m.psouth * m.pwest * m.peast);
}



// Notes:
/*
	Robot can sense and move.

	Sensing:
	   -When in the square, the robot will sense all four directions from its location for obstacles
	   -All maze edges are obstacles
	   -Robot can be wrong
	   -Probabilities:
		 90% Detects obstacle and is right
		 10% Detects obstacle and is wrong
		 95% Detects open square and is right
		 5% Detects open square and is wrong
	Moving:
	   -Can go straight, drift left, or drift right. Probabilities:
		 75% Goes straight
		 15% goes left
		 10% goes right
	   -If it hits an obstacle, it is bounced back to its prior position

	Robot does not know its initial location.

	[W N E S]
	Action Sequence: 0 Open, 1 Obstacle
	1. Sensing: [0, 0, 0, 0]
	2. Moving: N
	3. Sensing: [0, 0, 1, 0]
	4. Moving: N
	5. Sensing: [0, 1, 1, 0]
	6. Moving: W
	7. Sensing: [0, 1, 0, 0]
	8. Moving: S
	9. Sensing: [0, 0, 0, 0]

	Tutorial
	----------
	Filtering:
	P(S_t | Z_1 = z_1, z_2,...,Z_t=z_t) <> P(Z_t = z_t | S_t) P(S_t | Z_1=z_1,..,Z_t-1 = z_t-1)
	Prediction:
	P(S_t+1 | Z_1=z_1, ..., Z_t=z_t) = Sum( P(S_t+1 | S_t = s) P(S_T | Z_1 = a_z, ..., Z_t = z_t)

	Sensing: In P(Z_t | S_t),
	 Z_t = 4 random variables for each direction; Z_t = (Z_w@t, Z_n@t, Z_e@t, Z_s@t), Z_direction at T
	 State S_t conditionally independent:
	   P(Z_t | S_t) = P(Z_w@t | S_t) P(Z_n@t | S_t) P(Z_e@t | S_t) P(Z_s@t | S_t)

	Moving:
	 Provide at least two transition matrices for two different actions in testing (Ex: moving W, moving N)
	 Ex:
	  Moving W: P_w(S_t+1 = B | S_t = A) = 0.1
	  Moving N: P_n(S_t+1 = B | S_t = A) = 0.75

	Rows: A, B, C, D, E, F
	Columns: 1, 2, 3, 4, 5, 6, 7
	7x6 matrix
	Blocked tiles: A2, A3, A4, B1, B2, B3, B7, C1, C2, C6, C7, D1, D6, D7, E4, E5, E6, E7, F3, F4, F5, F6
	All edges are walls in: A-South, F-North
	West Edges: A1, B1, C1, D1, E1, F1
	East Edges: A7, B7, C7, D7, E7, F7
*/

